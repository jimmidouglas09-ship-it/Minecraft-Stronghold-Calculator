#define NOMINMAX
#include <windows.h>
#include <gdiplus.h>
#include <string>
#include <sstream>
#include <vector>
#include <memory>
#include <cmath>
#include <algorithm>
#include <map>
#include <iomanip>
#include <chrono>
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#pragma comment(lib, "gdiplus.lib")

using namespace Gdiplus;

// === Global Variables ===
HINSTANCE hInst;
WCHAR szTitle[] = L"Minecraft Coord Viewer";
WCHAR szWindowClass[] = L"MCViewerClass";
WCHAR szOverlayClass[] = L"MCOverlayClass";
ULONG_PTR gdiplusToken;
HWND hOverlayWnd = NULL;
bool overlayVisible = false; // NEW: Track overlay visibility

struct Vec3 { int x, y, z; };
Vec3 latestCoords = { 0, 0, 0 };
Vec3 coord1 = { 0, 0, 0 };
Vec3 coord2 = { 0, 0, 0 };
int capturePhase = 0; // 0 = none, 1 = first captured, 2 = second captured
double lastAngle = 0.0;

// Distance calculation variables
int distanceKeyPresses = 0;
double calculatedDistance = 0.0;
std::chrono::steady_clock::time_point lastDistanceKeyPress;
const int DISTANCE_KEY_TIMEOUT_MS = 2000; // 2 seconds timeout between presses

// New variables for validation
bool tabPressedFirst = false;
bool f4PressedFirst = false; // NEW: Track if F4 was pressed first
bool distanceValidationFailed = false;
std::wstring validationErrorMessage = L"";

// Stronghold calculation structures
struct StrongholdCell {
    double centerX, centerZ;
    double xMin, xMax, zMin, zMax;
    double prob;
    double distance;
    int distanceRange;
};

struct StrongholdCandidate {
    int projectionX, projectionZ;
    int netherX, netherZ; // NEW: Nether coordinates
    double cellCenterX, cellCenterZ;
    double rawProb;
    double conditionalProb;
    int distance;
    int distanceFromOrigin;
    int distanceRange;
    std::wstring bounds;
};

// Distance probabilities from the HTML version
std::map<int, double> distanceProbabilities = {
    {500, 0.0262}, {600, 0.0639}, {800, 0.1705}, {900, 0.1582}, {1000, 0.1427},
    {1100, 0.1204}, {1200, 0.0919}, {1300, 0.1133}, {1400, 0.1139}, {1500, 0.1228},
    {1700, 0.0586}, {1800, 0.0535}, {1900, 0.0610}, {2100, 0.0590}, {2200, 0.0431},
    {2300, 0.0375}, {2400, 0.0292}, {2500, 0.0493}, {2600, 0.0382}, {2700, 0.0347},
    {2800, 0.0258}, {3000, 0.0171}, {3100, 0.0169}, {3200, 0.0189}
};

std::vector<StrongholdCell> strongholdCells;
std::vector<StrongholdCandidate> strongholdCandidates;

// === Function Declarations ===
ATOM                MyRegisterClass(HINSTANCE hInstance);
ATOM                MyRegisterOverlayClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
BOOL                InitOverlay(HINSTANCE hInstance);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK    OverlayProc(HWND, UINT, WPARAM, LPARAM);
void                UpdateOverlay();
void                ShowOverlay(); // NEW: Function to show overlay
void                HideOverlay(); // NEW: Function to hide overlay

// === Utility Functions ===

std::unique_ptr<Bitmap> BitmapFromHWND(HWND hwnd) {
    if (IsIconic(hwnd)) ShowWindow(hwnd, SW_RESTORE);
    RECT rc; GetWindowRect(hwnd, &rc);
    int width = rc.right - rc.left;
    int height = rc.bottom - rc.top;

    HDC hdc = GetDC(hwnd);
    HDC memDC = CreateCompatibleDC(hdc);
    HBITMAP hBitmap = CreateCompatibleBitmap(hdc, width, height);
    HBITMAP hOldBitmap = (HBITMAP)SelectObject(memDC, hBitmap);

    PrintWindow(hwnd, memDC, PW_RENDERFULLCONTENT);
    auto pBitmap = std::make_unique<Bitmap>(hBitmap, nullptr);

    SelectObject(memDC, hOldBitmap);
    DeleteObject(hBitmap);
    DeleteDC(memDC);
    ReleaseDC(hwnd, hdc);

    return pBitmap;
}

int GetShownCoordinates(HWND hwnd, Vec3* coordinates) {
    auto pBitmap = BitmapFromHWND(hwnd);
    int width = pBitmap->GetWidth();
    int height = pBitmap->GetHeight();
    int searchWidth = std::max(width / 3, std::min(125, width));
    int searchHeight = height / 3;

    Gdiplus::BitmapData bitmapData;
    Gdiplus::Rect rect(0, 0, searchWidth, searchHeight);
    pBitmap->LockBits(&rect, ImageLockModeRead, PixelFormat32bppARGB, &bitmapData);

    int startTextX = 0, startTextY = 0, streak = 0;
    int stride = bitmapData.Stride / sizeof(ARGB);
    ARGB* pixels = static_cast<ARGB*>(bitmapData.Scan0);

    for (int y = 30; y < searchHeight; y++) {
        for (int x = 8; x < searchWidth; x++) {
            if (pixels[y * stride + x] == 0xFFFFFFFF) {
                if (!startTextX) { startTextX = x; startTextY = y; }
                streak++;
            }
            else if (streak < 4) streak = 0;
            else if (streak >= 4) break;
        }
        if (streak >= 4) break;
    }

    if (streak < 4) return 0;
    int scale = streak / 4;
    startTextX += 44 * scale;

    int coords[3] = { 0, 0, 0 };
    int index = 0;
    bool isSigned = false;

    while (startTextX < searchWidth) {
        unsigned int columnMask = 0;
        for (int dy = 0; dy < 7; dy++) {
            columnMask <<= 1;
            if (pixels[(startTextY + dy * scale) * stride + startTextX] == 0xFFFFFFFF)
                columnMask |= 1;
        }

        int digit = -1;
        switch (columnMask) {
        case 0b0111110: digit = 0; break;
        case 0b0000001: digit = 1; break;
        case 0b0100011: digit = 2; break;
        case 0b0100010: digit = 3; break;
        case 0b0001100: digit = 4; break;
        case 0b1110010: digit = 5; break;
        case 0b0011110: digit = 6; break;
        case 0b1100000: digit = 7; break;
        case 0b0110110: digit = 8; break;
        case 0b0110000: digit = 9; break;
        case 0b0001000: isSigned = true; break;
        case 0b0000011:
            if (isSigned) coords[index] *= -1;
            if (++index > 2) break;
            isSigned = false;
            break;
        default:
            if (index >= 2) break;
            if (isSigned) coords[index] *= -1;
            break;
        }

        if (digit != -1)
            coords[index] = coords[index] * 10 + digit;

        startTextX += 6 * scale;
    }

    if (isSigned && index <= 2) {
        coords[index] *= -1;
    }

    pBitmap->UnlockBits(&bitmapData);
    coordinates->x = coords[0];
    coordinates->y = coords[1];
    coordinates->z = coords[2];
    return 1;
}

double angleBetween(double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dz = y2 - y1;
    double angle = std::atan2(dx, -dz) * 180.0 / M_PI; // note the -dz
    if (angle < 0) angle += 360.0;
    return angle;
}

// === Distance Calculation ===

void handleDistanceKey() {
    // If TAB was pressed first, ignore F4 presses
    if (tabPressedFirst) {
        return;
    }

    // Mark that F4 was pressed first
    if (distanceKeyPresses == 0 && capturePhase == 0) {
        f4PressedFirst = true;
        ShowOverlay(); // NEW: Show overlay when F4 is first pressed
    }

    auto now = std::chrono::steady_clock::now();

    // Check if this is a new sequence (timeout exceeded)
    if (distanceKeyPresses > 0) {
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastDistanceKeyPress);
        if (elapsed.count() > DISTANCE_KEY_TIMEOUT_MS) {
            distanceKeyPresses = 0;
        }
    }

    distanceKeyPresses++;
    lastDistanceKeyPress = now;

    // Calculate distance: 3655 / (presses / 2)
    double divisor = distanceKeyPresses / 2.0;
    calculatedDistance = 3655.0 / divisor;

    UpdateOverlay();
}

// === Stronghold Calculation Functions ===

void generateStrongholdCells() {
    strongholdCells.clear();
    int cellSize = 272;
    int gap = 160;
    int totalStep = cellSize + gap; // 432 blocks between cell starts

    for (int xIndex = -15; xIndex <= 15; xIndex++) {
        for (int zIndex = -15; zIndex <= 15; zIndex++) {
            double xMin, xMax, zMin, zMax;

            // Calculate X bounds
            if (xIndex >= 0) {
                xMin = xIndex * totalStep;
                xMax = xMin + cellSize;
            }
            else {
                xMax = xIndex * totalStep - gap;
                xMin = xMax - cellSize;
            }

            // Calculate Z bounds
            if (zIndex >= 0) {
                zMin = zIndex * totalStep;
                zMax = zMin + cellSize;
            }
            else {
                zMax = zIndex * totalStep - gap;
                zMin = zMax - cellSize;
            }

            double centerX = (xMin + xMax) / 2.0;
            double centerZ = (zMin + zMax) / 2.0;

            // Check if this cell is at least 512 blocks from origin
            double distanceFromOrigin = std::sqrt(centerX * centerX + centerZ * centerZ);
            if (distanceFromOrigin >= 512) {
                // Find the closest distance range in our data
                int closestDistance = 500;
                double minDiff = std::abs(500 - (int)distanceFromOrigin);

                for (auto& pair : distanceProbabilities) {
                    double diff = std::abs(pair.first - (int)distanceFromOrigin);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestDistance = pair.first;
                    }
                }

                double prob = distanceProbabilities[closestDistance];

                StrongholdCell cell;
                cell.centerX = centerX;
                cell.centerZ = centerZ;
                cell.xMin = xMin;
                cell.xMax = xMax;
                cell.zMin = zMin;
                cell.zMax = zMax;
                cell.prob = prob;
                cell.distance = distanceFromOrigin;
                cell.distanceRange = closestDistance;

                strongholdCells.push_back(cell);
            }
        }
    }
}

void calculateStrongholdLocationWithDistance(double playerX, double playerZ, double eyeAngle, double targetDistance = -1) {
    strongholdCandidates.clear();
    distanceValidationFailed = false;
    validationErrorMessage = L"";

    double angleRad = eyeAngle * M_PI / 180.0;
    double dx = std::sin(angleRad);
    double dz = -std::cos(angleRad);

    // Use F4 distance if F4 was pressed first
    bool useTargetDistance = false;
    if (f4PressedFirst && calculatedDistance > 0) {
        useTargetDistance = true;
        targetDistance = calculatedDistance;
    }

    // If we have a target distance from F4, find the exact location or closest cell
    if (useTargetDistance) {
        // Calculate the exact point at the target distance along the ray
        double exactX = playerX + targetDistance * dx;
        double exactZ = playerZ + targetDistance * dz;

        // Find the closest stronghold cell to this exact point
        double closestDistance = DBL_MAX;
        StrongholdCell* closestCell = nullptr;
        double bestClampedX = exactX;
        double bestClampedZ = exactZ;

        for (auto& cell : strongholdCells) {
            // Find the closest point on this cell to the exact point
            double clampedX = std::max(cell.xMin, std::min(cell.xMax, exactX));
            double clampedZ = std::max(cell.zMin, std::min(cell.zMax, exactZ));

            double distanceToCell = std::sqrt(
                std::pow(clampedX - exactX, 2) + std::pow(clampedZ - exactZ, 2)
            );

            if (distanceToCell < closestDistance) {
                closestDistance = distanceToCell;
                closestCell = &cell;
                bestClampedX = clampedX;
                bestClampedZ = clampedZ;
            }
        }

        StrongholdCandidate candidate;

        // If closest cell is within 50 blocks, snap to cell boundary
        if (closestCell && closestDistance <= 50.0) {
            candidate.projectionX = (int)std::round(bestClampedX);
            candidate.projectionZ = (int)std::round(bestClampedZ);
            candidate.cellCenterX = closestCell->centerX;
            candidate.cellCenterZ = closestCell->centerZ;
            candidate.rawProb = closestCell->prob;
            candidate.distanceFromOrigin = (int)std::round(closestCell->distance);
            candidate.distanceRange = closestCell->distanceRange;

            std::wstringstream ss;
            ss << L"(" << (int)closestCell->xMin << L", " << (int)closestCell->zMin
                << L") to (" << (int)closestCell->xMax << L", " << (int)closestCell->zMax << L")";
            candidate.bounds = ss.str();
        }
        else {
            // More than 50 blocks away, use exact F4 distance point
            candidate.projectionX = (int)std::round(exactX);
            candidate.projectionZ = (int)std::round(exactZ);
            candidate.cellCenterX = exactX;
            candidate.cellCenterZ = exactZ;
            candidate.rawProb = 0.1; // Default probability for non-cell locations
            candidate.distanceFromOrigin = (int)std::round(targetDistance);
            candidate.distanceRange = (int)std::round(targetDistance / 100) * 100; // Round to nearest 100
            candidate.bounds = L"Exact F4 distance point";
        }

        candidate.netherX = (int)std::round(candidate.projectionX / 8.0);
        candidate.netherZ = (int)std::round(candidate.projectionZ / 8.0);
        candidate.conditionalProb = 1.0; // 100% since F4 gives exact distance
        candidate.distance = (int)std::round(targetDistance);

        strongholdCandidates.push_back(candidate);
    }
    else {
        // Original logic for when no F4 distance is available
        for (const auto& cell : strongholdCells) {
            double toCenterX = cell.centerX - playerX;
            double toCenterZ = cell.centerZ - playerZ;
            double t = (toCenterX * dx + toCenterZ * dz);

            if (t > 0) {
                double projectionX = playerX + t * dx;
                double projectionZ = playerZ + t * dz;

                if (projectionX >= cell.xMin && projectionX <= cell.xMax &&
                    projectionZ >= cell.zMin && projectionZ <= cell.zMax) {

                    double distanceToProjection = std::sqrt(
                        std::pow(projectionX - playerX, 2) +
                        std::pow(projectionZ - playerZ, 2)
                    );

                    double clampedX = std::max(cell.xMin, std::min(cell.xMax, projectionX));
                    double clampedZ = std::max(cell.zMin, std::min(cell.zMax, projectionZ));

                    StrongholdCandidate candidate;
                    candidate.projectionX = (int)std::round(clampedX);
                    candidate.projectionZ = (int)std::round(clampedZ);
                    candidate.netherX = (int)std::round(clampedX / 8.0);
                    candidate.netherZ = (int)std::round(clampedZ / 8.0);
                    candidate.cellCenterX = cell.centerX;
                    candidate.cellCenterZ = cell.centerZ;
                    candidate.rawProb = cell.prob;
                    candidate.distance = (int)std::round(distanceToProjection);
                    candidate.distanceFromOrigin = (int)std::round(cell.distance);
                    candidate.distanceRange = cell.distanceRange;

                    std::wstringstream ss;
                    ss << L"(" << (int)cell.xMin << L", " << (int)cell.zMin
                        << L") to (" << (int)cell.xMax << L", " << (int)cell.zMax << L")";
                    candidate.bounds = ss.str();

                    strongholdCandidates.push_back(candidate);
                }
            }
        }

        // Calculate conditional probabilities for non-F4 case
        double totalRawProb = 0.0;
        for (const auto& candidate : strongholdCandidates) {
            totalRawProb += candidate.rawProb;
        }

        if (totalRawProb > 0) {
            for (auto& candidate : strongholdCandidates) {
                candidate.conditionalProb = candidate.rawProb / totalRawProb;
            }
        }

        // Sort by conditional probability (highest first)
        std::sort(strongholdCandidates.begin(), strongholdCandidates.end(),
            [](const StrongholdCandidate& a, const StrongholdCandidate& b) {
                return a.conditionalProb > b.conditionalProb;
            });
    }
}

// === NEW: Overlay Show/Hide Functions ===

void ShowOverlay() {
    if (hOverlayWnd && !overlayVisible) {
        ShowWindow(hOverlayWnd, SW_SHOW);
        SetWindowPos(hOverlayWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
        overlayVisible = true;
        UpdateOverlay();
    }
}

void HideOverlay() {
    if (hOverlayWnd && overlayVisible) {
        ShowWindow(hOverlayWnd, SW_HIDE);
        overlayVisible = false;
    }
}

// === Overlay Window Functions ===

void UpdateOverlay() {
    if (hOverlayWnd && overlayVisible) {
        InvalidateRect(hOverlayWnd, NULL, TRUE);
    }
}

BOOL InitOverlay(HINSTANCE hInstance) {
    // Get screen dimensions
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);

    // Position overlay in top-right corner - make it much bigger for multiple coordinates
    int overlayWidth = 450;
    int overlayHeight = 400;
    int x = screenWidth - overlayWidth - 20;
    int y = 20;

    hOverlayWnd = CreateWindowExW(
        WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE,
        szOverlayClass,
        L"MC Overlay",
        WS_POPUP,  // CHANGED: Removed WS_VISIBLE to start hidden
        x, y, overlayWidth, overlayHeight,
        nullptr, nullptr, hInstance, nullptr
    );

    if (!hOverlayWnd) {
        MessageBox(NULL, L"Failed to create overlay window", L"Error", MB_OK);
        return FALSE;
    }

    // Make window semi-transparent with black as transparent color
    SetLayeredWindowAttributes(hOverlayWnd, RGB(0, 0, 0), 200, LWA_COLORKEY | LWA_ALPHA);

    // DON'T show the window initially - it starts hidden
    overlayVisible = false; // CHANGED: Initialize as hidden

    return TRUE;
}

LRESULT CALLBACK OverlayProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);

        Graphics graphics(hdc);
        graphics.SetSmoothingMode(SmoothingModeAntiAlias);

        // Use dark background
        graphics.Clear(Color(240, 15, 20, 35)); // Dark blue-gray background

        // Draw border
        Pen borderPen(Color(255, 100, 150, 200), 2);
        RECT rect;
        GetClientRect(hWnd, &rect);
        graphics.DrawRectangle(&borderPen, 1, 1, rect.right - 2, rect.bottom - 2);

        // Improved fonts - larger and clearer
        FontFamily fontFamily(L"Consolas"); // Monospace font for better alignment
        Font headerFont(&fontFamily, 16, FontStyleBold, UnitPixel);
        Font coordFont(&fontFamily, 14, FontStyleBold, UnitPixel);
        Font infoFont(&fontFamily, 12, FontStyleRegular, UnitPixel);
        Font smallFont(&fontFamily, 11, FontStyleRegular, UnitPixel);

        // Better color scheme
        SolidBrush whiteBrush(Color(255, 255, 255, 255));
        SolidBrush lightGrayBrush(Color(255, 200, 200, 200));
        SolidBrush greenBrush(Color(255, 120, 255, 120));
        SolidBrush yellowBrush(Color(255, 255, 220, 100));
        SolidBrush orangeBrush(Color(255, 255, 165, 0));
        SolidBrush redBrush(Color(255, 255, 120, 120));
        SolidBrush cyanBrush(Color(255, 100, 200, 255)); // For nether coords

        int y = 12;
        int x = 15;

        // Title with better styling
        graphics.DrawString(L"Stronghold Finder", -1, &headerFont,
            PointF((REAL)x, (REAL)y), &whiteBrush);
        y += 25;

        // Status line
        if (f4PressedFirst && distanceKeyPresses > 0) {
            std::wstringstream ss;
            ss << L"Distance: " << std::fixed << std::setprecision(0)
                << calculatedDistance << L" blocks (F4 x" << distanceKeyPresses << L")";
            graphics.DrawString(ss.str().c_str(), -1, &infoFont,
                PointF((REAL)x, (REAL)y), &yellowBrush);
            y += 20;
        }
        else if (tabPressedFirst) {
            graphics.DrawString(L"Distance calculation skipped", -1, &infoFont,
                PointF((REAL)x, (REAL)y), &lightGrayBrush);
            y += 20;
        }
        else if (capturePhase == 0) {
            graphics.DrawString(L"Press F4 for distance, then TAB twice", -1, &infoFont,
                PointF((REAL)x, (REAL)y), &lightGrayBrush);
            y += 20;
        }

        // Show validation error if present
        if (distanceValidationFailed) {
            graphics.DrawString(L"? DISTANCE MISMATCH!", -1, &infoFont,
                PointF((REAL)x, (REAL)y), &redBrush);
            y += 20;
        }

        // Show current phase
        if (capturePhase == 1) {
            graphics.DrawString(L"? Press TAB at second point", -1, &infoFont,
                PointF((REAL)x, (REAL)y), &orangeBrush);
            y += 20;
        }
        else if (capturePhase == 2 && !strongholdCandidates.empty()) {
            std::wstringstream ss;
            ss << L"Direction: " << std::fixed << std::setprecision(1) << lastAngle << L"°";
            graphics.DrawString(ss.str().c_str(), -1, &infoFont,
                PointF((REAL)x, (REAL)y), &lightGrayBrush);
            y += 25;

            // Header for coordinates
            graphics.DrawString(L"Overworld Coords    Nether Coords    Probability", -1, &smallFont,
                PointF((REAL)x, (REAL)y), &lightGrayBrush);
            y += 18;

            // Show top stronghold locations (up to 8)
            int maxCandidates = std::min(8, (int)strongholdCandidates.size());
            for (int i = 0; i < maxCandidates; i++) {
                const auto& candidate = strongholdCandidates[i];

                // Color coding based on probability
                SolidBrush* brush;
                if (i == 0) {
                    brush = distanceValidationFailed ? &redBrush : &greenBrush;
                }
                else if (candidate.conditionalProb > 0.1) {
                    brush = &yellowBrush;
                }
                else {
                    brush = &lightGrayBrush;
                }

                // Format coordinates nicely
                std::wstringstream coordSS;
                coordSS << std::setw(6) << candidate.projectionX
                    << L"," << std::setw(6) << candidate.projectionZ;

                std::wstringstream netherSS;
                netherSS << std::setw(6) << candidate.netherX
                    << L"," << std::setw(6) << candidate.netherZ;

                std::wstringstream probSS;
                probSS << std::fixed << std::setprecision(1)
                    << (candidate.conditionalProb * 100.0) << L"%";

                // Draw overworld coordinates
                graphics.DrawString(coordSS.str().c_str(), -1, &coordFont,
                    PointF((REAL)x, (REAL)y), brush);

                // Draw nether coordinates
                graphics.DrawString(netherSS.str().c_str(), -1, &coordFont,
                    PointF((REAL)(x + 140), (REAL)y), &cyanBrush);

                // Draw probability
                graphics.DrawString(probSS.str().c_str(), -1, &coordFont,
                    PointF((REAL)(x + 270), (REAL)y), brush);

                // Show distance for top candidate
                if (i == 0) {
                    std::wstringstream distSS;
                    distSS << L" (" << candidate.distance << L"m)";
                    graphics.DrawString(distSS.str().c_str(), -1, &smallFont,
                        PointF((REAL)(x + 340), (REAL)y + 2), &lightGrayBrush);
                }

                y += 22;
            }

            y += 10;
            graphics.DrawString(L"Press TAB to reset", -1, &smallFont,
                PointF((REAL)x, (REAL)y), &lightGrayBrush);
        }
        else if (capturePhase == 0 && f4PressedFirst) {
            graphics.DrawString(L"? Now press TAB twice for direction", -1, &infoFont,
                PointF((REAL)x, (REAL)y), &orangeBrush);
        }

        EndPaint(hWnd, &ps);
    }
    break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// === Main Entry ===

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPWSTR    lpCmdLine,
    _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    GdiplusStartupInput gdiplusStartupInput;
    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

    generateStrongholdCells();

    MyRegisterClass(hInstance);
    MyRegisterOverlayClass(hInstance);

    if (!InitInstance(hInstance, nCmdShow)) return FALSE;
    if (!InitOverlay(hInstance)) return FALSE;

    MSG msg;
    while (GetMessage(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    GdiplusShutdown(gdiplusToken);
    return (int)msg.wParam;
}

// === Window Class Registration ===

ATOM MyRegisterClass(HINSTANCE hInstance) {
    WNDCLASSEXW wcex = {};
    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WndProc;
    wcex.hInstance = hInstance;
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszClassName = szWindowClass;
    return RegisterClassExW(&wcex);
}

ATOM MyRegisterOverlayClass(HINSTANCE hInstance) {
    WNDCLASSEXW wcex = {};
    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = OverlayProc;
    wcex.hInstance = hInstance;
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
    wcex.lpszClassName = szOverlayClass;
    return RegisterClassExW(&wcex);
}

// === Window Init ===

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) {
    hInst = hInstance;
    HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW ^ WS_THICKFRAME,
        CW_USEDEFAULT, 0, 500, 700, nullptr, nullptr, hInstance, nullptr);
    if (!hWnd) return FALSE;

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    RegisterHotKey(hWnd, 1, 0, VK_TAB); // Tab key
    RegisterHotKey(hWnd, 2, 0, VK_F4); // F4 key

    return TRUE;
}

// === Window Procedure ===

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_HOTKEY:
    {
        if (wParam == 1) { // Tab key
            HWND mcHwnd = FindWindow(NULL, L"Minecraft");
            if (mcHwnd && GetShownCoordinates(mcHwnd, &latestCoords)) {
                if (capturePhase == 0) {
                    // First TAB press - only mark as TAB first if F4 wasn't pressed yet
                    if (distanceKeyPresses == 0) {
                        tabPressedFirst = true;
                        ShowOverlay(); // NEW: Show overlay when TAB is first pressed
                    }
                    coord1 = latestCoords;
                    capturePhase = 1;
                }
                else if (capturePhase == 1) {
                    coord2 = latestCoords;
                    lastAngle = angleBetween(coord1.x, coord1.z, coord2.x, coord2.z);
                    capturePhase = 2;

                    // FIXED: Always use F4 distance when F4 was pressed first
                    double targetDistance = -1;
                    if (f4PressedFirst && calculatedDistance > 0) {
                        targetDistance = calculatedDistance;
                    }
                    calculateStrongholdLocationWithDistance(coord1.x, coord1.z, lastAngle, targetDistance);

                    // Copy top stronghold locations to clipboard (multiple coordinates)
                    std::wstringstream ss;
                    if (!strongholdCandidates.empty()) {
                        ss << L"Stronghold Locations:\n";
                        int maxForClipboard = std::min(5, (int)strongholdCandidates.size());
                        for (int i = 0; i < maxForClipboard; i++) {
                            const auto& candidate = strongholdCandidates[i];
                            ss << L"#" << (i + 1) << L": Overworld (" << candidate.projectionX
                                << L", " << candidate.projectionZ << L") - Nether ("
                                << candidate.netherX << L", " << candidate.netherZ << L") - "
                                << std::fixed << std::setprecision(1)
                                << (candidate.conditionalProb * 100.0) << L"%\n";
                        }

                        // Add warning to clipboard if distance validation failed
                        if (distanceValidationFailed) {
                            ss << L"\nWARNING: Distance mismatch detected!";
                        }
                    }
                    else {
                        ss << L"Angle: " << lastAngle << L"° - No strongholds found";
                    }
                    std::wstring text = ss.str();

                    OpenClipboard(NULL);
                    EmptyClipboard();
                    HGLOBAL hGlob = GlobalAlloc(GMEM_MOVEABLE, (text.size() + 1) * sizeof(wchar_t));
                    if (hGlob) {
                        memcpy(GlobalLock(hGlob), text.c_str(), (text.size() + 1) * sizeof(wchar_t));
                        GlobalUnlock(hGlob);
                        SetClipboardData(CF_UNICODETEXT, hGlob);
                    }
                    CloseClipboard();
                }
                else {
                    // Third press resets everything
                    capturePhase = 0;
                    coord1 = { 0,0,0 };
                    coord2 = { 0,0,0 };
                    lastAngle = 0.0;
                    distanceKeyPresses = 0;
                    calculatedDistance = 0.0;
                    strongholdCandidates.clear();
                    tabPressedFirst = false;
                    f4PressedFirst = false; // Reset F4 flag
                    distanceValidationFailed = false;
                    validationErrorMessage = L"";
                    HideOverlay(); // NEW: Hide overlay when resetting
                }

                UpdateOverlay();
                InvalidateRect(hWnd, NULL, TRUE);
            }
        }
        else if (wParam == 2) { // F4 key
            handleDistanceKey();
        }
    }
    break;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);

        Graphics graphics(hdc);
        graphics.SetSmoothingMode(SmoothingModeAntiAlias);
        graphics.Clear(Color(30, 30, 30));

        FontFamily fontFamily(L"Segoe UI");
        Font font(&fontFamily, 12, FontStyleRegular, UnitPixel);
        Font smallFont(&fontFamily, 10, FontStyleRegular, UnitPixel);
        Font tableFont(&fontFamily, 11, FontStyleRegular, UnitPixel);
        SolidBrush whiteBrush(Color(240, 240, 240));
        SolidBrush grayBrush(Color(180, 180, 180));
        SolidBrush greenBrush(Color(100, 200, 100));
        SolidBrush yellowBrush(Color(255, 220, 100));
        SolidBrush redBrush(Color(255, 100, 100));
        SolidBrush cyanBrush(Color(100, 200, 255));

        int marginX = 15;
        int y = 15;

        Font headerFont(&fontFamily, 14, FontStyleBold, UnitPixel);
        graphics.DrawString(L"Minecraft Stronghold Finder", -1, &headerFont,
            PointF((REAL)marginX, (REAL)y), &whiteBrush);
        y += 35;

        std::wstringstream ss;
        ss << L"Current Position:\n"
            << L"X: " << latestCoords.x << L"\n"
            << L"Y: " << latestCoords.y << L"\n"
            << L"Z: " << latestCoords.z << L"\n";

        graphics.DrawString(ss.str().c_str(), -1, &font,
            PointF((REAL)marginX, (REAL)y), &grayBrush);
        y += 85;

        // Distance info
        if (f4PressedFirst && distanceKeyPresses > 0) {
            std::wstringstream distSS;
            distSS << L"F4 Distance Calculation:\n"
                << L"Key presses: " << distanceKeyPresses << L"\n"
                << L"Calculated distance: " << std::fixed << std::setprecision(0)
                << calculatedDistance << L" blocks\n";
            graphics.DrawString(distSS.str().c_str(), -1, &font,
                PointF((REAL)marginX, (REAL)y), &yellowBrush);
            y += 55;
        }
        else if (tabPressedFirst) {
            graphics.DrawString(L"F4 key disabled (TAB was pressed first)\n", -1, &font,
                PointF((REAL)marginX, (REAL)y), &grayBrush);
            y += 20;
        }

        // Show validation error in main window
        if (distanceValidationFailed && !validationErrorMessage.empty()) {
            Font errorFont(&fontFamily, 10, FontStyleBold, UnitPixel);
            // Word wrap the error message
            RectF layoutRect((REAL)marginX, (REAL)y, 450.0f, 60.0f);
            graphics.DrawString(validationErrorMessage.c_str(), -1, &errorFont,
                layoutRect, nullptr, &redBrush);
            y += 65;
        }

        if (capturePhase == 0) {
            if (!f4PressedFirst && !tabPressedFirst) {
                graphics.DrawString(L"Instructions:\n"
                    L"1. Press F4 multiple times for distance calculation\n"
                    L"2. Press TAB twice for direction calculation\n"
                    L"   (or press TAB first to skip distance)", -1, &font,
                    PointF((REAL)marginX, (REAL)y), &whiteBrush);
            }
            else if (tabPressedFirst) {
                graphics.DrawString(L"TAB pressed first - distance calculation skipped.\n"
                    L"Press TAB again for direction calculation.", -1, &font,
                    PointF((REAL)marginX, (REAL)y), &whiteBrush);
            }
            else if (f4PressedFirst) {
                graphics.DrawString(L"Distance calculated! Now press TAB twice for direction.", -1, &font,
                    PointF((REAL)marginX, (REAL)y), &greenBrush);
            }
        }
        else if (capturePhase == 1) {
            std::wstringstream firstSS;
            firstSS << L"First point captured: (" << coord1.x << L", " << coord1.z << L")\n"
                << L"Press TAB at second point to calculate direction.";
            graphics.DrawString(firstSS.str().c_str(), -1, &font,
                PointF((REAL)marginX, (REAL)y), &yellowBrush);
        }
        else if (capturePhase == 2) {
            std::wstringstream angleSS;
            angleSS << L"Eye Direction: " << std::fixed << std::setprecision(1)
                << lastAngle << L"°\n";

            if (!strongholdCandidates.empty()) {
                angleSS << L"\nStronghold Locations (Overworld / Nether):";
            }
            else {
                angleSS << L"\nNo strongholds found in this direction.";
            }

            SolidBrush* angleBrush = distanceValidationFailed ? &redBrush : &greenBrush;
            graphics.DrawString(angleSS.str().c_str(), -1, &font,
                PointF((REAL)marginX, (REAL)y), angleBrush);

            if (!strongholdCandidates.empty()) {
                y += 55;

                // Table header
                graphics.DrawString(L"Rank  Overworld Coords    Nether Coords      Probability  Distance", -1, &smallFont,
                    PointF((REAL)marginX, (REAL)y), &grayBrush);
                y += 20;

                // Show detailed candidate list
                int maxCandidates = std::min(10, (int)strongholdCandidates.size());
                for (int i = 0; i < maxCandidates; i++) {
                    const auto& candidate = strongholdCandidates[i];

                    std::wstringstream candidateSS;
                    candidateSS << L"#" << (i + 1) << L"   ("
                        << std::setw(5) << candidate.projectionX << L"," << std::setw(5) << candidate.projectionZ << L")   ("
                        << std::setw(4) << candidate.netherX << L"," << std::setw(4) << candidate.netherZ << L")      "
                        << std::fixed << std::setprecision(1) << std::setw(5)
                        << (candidate.conditionalProb * 100.0) << L"%     "
                        << candidate.distance << L"m";

                    SolidBrush* brush;
                    if (i == 0) {
                        brush = distanceValidationFailed ? &redBrush : &greenBrush;
                    }
                    else if (candidate.conditionalProb > 0.1) {
                        brush = &yellowBrush;
                    }
                    else {
                        brush = &grayBrush;
                    }

                    graphics.DrawString(candidateSS.str().c_str(), -1, &tableFont,
                        PointF((REAL)marginX, (REAL)y), brush);
                    y += 18;
                }

                y += 10;
                graphics.DrawString(L"Top locations copied to clipboard. Press TAB to reset.", -1, &font,
                    PointF((REAL)marginX, (REAL)y), &whiteBrush);
            }
        }

        EndPaint(hWnd, &ps);
    }
    break;

    case WM_DESTROY:
        UnregisterHotKey(hWnd, 1);
        UnregisterHotKey(hWnd, 2);
        if (hOverlayWnd) {
            DestroyWindow(hOverlayWnd);
        }
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
